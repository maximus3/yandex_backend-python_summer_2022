# Url-shortener application 

## Идея фичи

Пользователям сервиса предоставляется возможность сократить ссылку в непонятный набор символов. 
Идея фичи состоит в том, чтобы предоставлять пользователям временную красивую и понятную ссылку, которую легко запомнить.

## Продуктовые гипотезы

* Если пользователи смогут делать красивые ссылки, то будут чаще пользоваться сервисом, потому что их будет легче запоминать получателям ссылок.
* Если люди будут видеть красивую ссылку, то будут чаще на нее кликать, потому что будет больше доверия к содержанию ссылки.

## Трудозатраты

* Потребуется изменить классы, хранящие данные о ссылках, то есть, как минимум, класс с базой данных UrlStorage и MakeShorterRequest, добавив новые поля.
* Потребуется добавить новый enum TimeToLiveUnit.
* Потребуется изменить логику создания коротких ссылок, добавив обработку VIP ссылок.
* Потребуется добавить обработку удаления VIP ссылки, если истек ее срок при обращении к сервису.

## MVP

Сделать MVP будет сложно, потому что создатель ссылки должен сам задавать короткое название, а это и есть почти весь функционал.

## Архитектура

* Добавление enum TimeToLiveUnit:
  - SECONDS
  - MINUTES
  - HOURS
  - DAYS
* Изменение полей БД:
  * UrlStorage:
    * Добавление поля `is_vip` (bool)
    * Добавление поля `dt_expiration` (TIMESTAMP)
* Изменение полей схем:
  * GetInfoAboutLinkResponse:
    * Добавление поля `is_vip` (bool)
    * Добавление поля `dt_expiration` (TIMESTAMP)
  * MakeShorterRequest:
    * Добавление поля `vip_key` (string)
    * Добавление поля `time_to_live` (integer)
    * Добавление поля `time_to_live_unit` (string)
* Изменение логики обработки добавления VIP ссылки:
  * Проверка на существование такой vip-ссылки
  * Проверка на истекший срок действия vip-ссылки
  * Добавление даты истечения действия для vip-ссылки
* Изменение логики обращения к vip-ссылкам:
  * Проверка на истекший срок действия vip-ссылки
  * Удаление vip-ссылки из базы данных, если истек срок действия

## AB-тест

Дать части пользователям доступ к VIP ссылкам и посмотреть на метрики.

## Метрики

* Количество пользователей
* Количество новых пользователей
* Изменение количества ссылок, созданных старыми пользователями
* Количество VIP ссылок по отношению к обычным

# Описание исходного задания

## Описание и технические требования

На лекции мы проследили за процессом, как разрабатывать новые крутые продуктовые фичи в нашем сервисе Такси. Давайте реализуем что-то похожее на небольшом проекте UrlShortener. Он всего лишь умеет укорачивать урлы и дает немного управления над созданными редиректами (можно посмотреть статистику использования и удалить ссылку).

Представьте, что нам необходимо вывести наш сервис UrlShortener на новый качественный уровень на рынке подобных систем. Надо завоевать долю на рынке и нарастить количество активных пользователей с X до Y %. Это стратегическая цель. Но как ее достичь?

Дальше задание разделяется на 2 пути: вы можете взять описанную ниже фичу либо придумать свою крутую. Главное - реализовать в коде и показать путь фичи от идеи до воплощения. Если пойдете по второму пути, то все равно нужно реализовать в коде предложенную фичу, чтобы наши автотесты проверили ваш код.

В требованиях к заданию есть творческая составляющая - нужно будет написать отчет в формате md. Если идете путем своей фичи - описываете в этой части свою фичу, если нет - то нашу. Подробности ниже.

### Давайте сначала присмотримся к фиче, предложенной нами

Кто-то проанализировал рынок за вас и решил, что killer-фичей, которую так необходимо реализовать во что бы то ни стало, является "VIP ссылки"!

Что это? Всё просто. Вы помните, что UrlShortener возвращает произвольную комбинацию символов в укороченном URL. А в VIP ссылках, это не так: пользователь сам указывает, какой будет его короткая ссылка, конечно, только если заданная им комбинация символов свободна.

Формальное описание интерфейса на OpenAPI 3.0 тут [openapi.yaml](openapi.yaml)

А ниже для общего представления неформальное описание.

make_shorter на входе получает:
```
url = "user-defined-long-url"
optional vip_key = "user-defined-symbols"
optional time_to_live = 1
optional time_to_live_unit = SECONDS, MINUTES, HOURS, DAYS
```

Максимальный TimeToLive не должен превышать 2 дней (иначе красивые vip ссылки закончатся).

В ответ на операцию приходит
```
short_url = "example.com/xyz" - короткая ссылка
secret_key - ключ для управления ссылкой
```

Ну или ошибка 400, если есть какие-то проблемы с входными параметрами, например, если vip_key уже занят или переданы невалидные значения для TTL.

### А что если у меня своя классная идея?
Все просто - опиши ее и реализуй, а потом презентуй в коротком (до 2 минут) видео ролике - загрузи видео на любой открытый видеохостинг - ютуб, например. В ролике необходимо показать функциональность твоей фичи. Не забудь реализовать базовую фичу "vip ссылки", она будет проверена автоматически.

### Требования к результату домашней работы

0. Форкнуть (fork) данный репозиторий с заданием в свой репозиторий;
1. Необходимо описать идею (vip ссылки или свою) в 1-2 предложениях;
2. Сформулировать продуктовые гипотезы - 1-2 штуки в формате, как было на лекции;
3. Оценить примерные трудозатраты (попробуй аргументировать оценку, например, требуемым количеством новых классов, объемом кода);
4. Придумать, можно ли сделать MVP, если да, то как он будет выглядеть и сколько это займет времени;
5. Проработать архитектуру и описать ее в тексте (в качестве формального описания подойдут openapi описание, диаграммы классов, компонентные диаграммы - в зависимости от того, что лучше отразит суть изменений и, что по вашему мнению будет понятнее проверяющему);
6. Реализовать полное решение идеи в коде. Если пошли по пути разработки своей супер-идеи, то не забудьте реализовать vip ссылки;
7. Добиться чтобы все предоставленные в исходном репозитории тесты на vip ссылки проходили успешно, внося правки в код сервиса, а не тестов :) ;
8. Придумать AB-тест - какие выборки пользователей будут в эксперименте? Какие параметры фичи будем проверять в каждой выборке?
9. Выбрать и описать набор наблюдаемых продуктовых метрик, по которым можно сделать вывод, что фича "взлетела". Какие значения метрик ожидаем увидеть?
10. Сделать отчет в файле README.md (имеющийся удалить, свой добавить) в своем репозитории с ответами на эти вопросы.

Если идешь путем разработки своей фичи, то отчет пиши про неё. Если реализуешь только vip ссылки, то отчет по ней.

Если что-то непонятно, смело задавай вопросы своему ментору.

## Работа с приложением

### Требования

Необходимо, чтобы были установлены следующие компоненты:

- `Docker` и `docker-compose`
- `Python 3.10`
- `Poetry`

### Установка

1. Создание виртуального окружения и установка зависимостей
```commandline
poetry install
```

2. Активация виртуального окружения

```commandline
poetry shell
```


### Запуск

0. Создать .env файл
```dotenv
POSTGRES_DB=...
POSTGRES_USER=...
POSTGRES_PASSWORD=...
POSTGRES_HOST=...
POSTGRES_PORT=5432
```

2. Создание базы в docker-контейнере (чтобы не работать с локальной базой):
```commandline
make db
```
2. Выполнение миграций:
```commandline
make migrate
```
3. Запуск приложения:
```commandline
make run
```

Посмотреть документацию можно после запуска приложения по адресу `http://127.0.0.1:8080/swagger`.
### Тестирование

- Запуск тестов со всеми необходимыми флагами:
```commandline
make test
```

- Запуск тестов с генерацией отчета о покрытии:
```commandline
make test-cov
```

### Статический анализ

- Запуск линтеров
```commandline
make lint
```

- Запуск форматирования кода
```commandline
make format
```

### Дополнительные команды

- Создание новой ревизии:
```commandline
make revision
```
- Открытие базы данных внутри Docker-контейнера:
```commandline
make open_db
```

- Вывести список всех команд и их описание:
```commandline
make all
```
