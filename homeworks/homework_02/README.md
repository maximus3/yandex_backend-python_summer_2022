# Pharmacy shopping cart checker

## Description
Сервис для проверки корзины онлайн аптеки на возможность покупки товаров пользователем.

## Run

Запуск сервиса в docker-контейнере:
`make docker`

Сервис будет доступен по адресу: [http://localhost:8090/](http://localhost:8090/)

Запуск сервиса в обычном режиме:
`make venv`

Далее необходимо активировать виртуальное окружение и выполнить:

`make install && make docker-up-psql && make up`

## Commands

### Docker clean, build, up detach with psql
    make docker-d

### Docker clean, build, up, clean
    make docker

### Up docker container
    make docker-up

### Down docker container
    make docker-down

### Create venv (if no docker)
    make venv

### Run app
    make up

### Run unit tests
    make test

### Run online unit tests
    make online-test

### Run linters
    make lint

### Run formatters
    make format

### Run format and lint code then run tests
    make check
	
## Task Description

Домашние задание №2

У нас есть онлайн аптека, которая позволяет покупать разные товары(безрецептурные(в том числе простые товары вроде воды, которые к препаратам отношения не имеют), рецептурные(доступны любому врачу, либо пользователю у которого есть рецепт), специальные - доступны только для врачей конкретных специальностей например - товары для анестезиологов можно продавать только анестизиологам).

Необходимо создать отдельный сервис проверки корзины - на вход приходит запрос, который содержит id пользователя и список товаров, а в ответ выдать список позиций по которым есть проблемы.
Данные о товарах и пользователях хранятся в локальной базе данных.

В сервисе необходимо создать обработчик запроса типа GET принимающий следующие парметры:

user_id - Integer(айди врача или пользователя, он сквозной, т.е уникальный в рамках всей системы)<br>
item_id - список строковых значений вида type_id где: type - строковое описание типа товара, id - числовой идентификатор товара

Пример товара - special_123, special - тип, 123 - id, валидность структуры товара - гарантируется, валидность типа и идентификатора - нет, то есть
может прилететь товар вида ab12_qwerty.
user_id - гарантированно int, наличие в базе - не гаранитрованно

Пример запроса:
http://localhost:80/check?user_id=123&item_id=special_26&item_id=common_25


Вся нужная информация будет лежать в базе данных.

**В папке datbase/postgresql-docke-image лежит docker-compose.yml, его запуск создаст базу наполненую всеми нужными товарами и пользователями.
Схема нарисована в pharmacy_er.png, лежит там же где и readme, настоятельно рекомендую начать с ее изучения**.

Пользователи относятся к двум категориям - обычные пользователи и врачи, лежат в разных таблицах с разными схемами. Определить кем является пользователь нужно реализуя какую то архитектурную хитрость и обосновать ее выбор - любую на свое усмотрение или не использовать вовсе но обосновать почему этого делать не стоит.
Задача получения пользователя сводится к тому, что бы попытаться найти его в 1 источнике, если не вышло попытаться найти в другом источнике(в контексте задачи источники это разные таблицы), ищем либо пока не найдем, либо пока не проверим все источники(в нашем случае их 2 но надо понимать что в будущем может быть больше), надо разрабатывать код с прицелом на увеличение числа источников данных и типов пользователей


Необходимо описать стратегии валидации товаров - проверка рецептурных, проверка специальных товаров, и проверка простых товаров.
Перед валидацией необходимо определить категорию товара, и исходя из категории определить как его проверять, товары лежат в разных таблицах, рецепты для пользователей лежат в отдельной таблице.
Решение нужно реализовывать  таким образом, что бы при добавлении нового вида товаров потребовалось сделать минимум модификаций в уже существующий код.


Категории товаров - рецептурные, безрецептурные, специальные.(безрецептурные и простые лежат в однйо таблице и прилетают с одним типом - common)
Специальные товары - тип special<br>
Обычные товары - common<br>
Рецептурные - receipt<br>

При парсинге категории товара - приводить ее к нижнему регистру и возвращать в нижнем регистре.
Товары хранятся в разных таблицах, определить где искать товар можно по типу (special/common/receipt), из базы можно получить значение по id(целочисленная часть)
Список рецептов по пользователям - реализован через промежуточную таблицу связывающую рецептурные товары и пользователей.
В таблице специальных товаров описано к какой сфере они относятся(например товары доступные к покупке только хирургам или только анестезиологам).


Возможные ситуации описаны ниже.


Структура ответа:

200 OK  
[{“item_id”: string, “problem”: string}] - формат itemId - такой же как на входе, в нижнем регистре, если прилетел Common_123 - вернуть common_123,
если с товаром все окей и с пользователем все окей - не нужно возвращать, в ответ вписываем только проблемные товары и их причины



Обработка краевых случаев<br>
Для каждого вида ошибки использовать свой код в ответе.
Коды ошибок для ответов:


| Ошибка                                                                             |    Код ответа  (problem)    |
|------------------------------------------------------------------------------------|:---------------------------:|
| Ошибка парсинга категории товара - категория не найдена, в этом случае id не важен |       WRONG_CATEGORY        |
| Ошибка парсинга id товара   (категория спарсилась правильно - но id кривой)        |    INCORRECT_ITEM_ID        |
| Товар не найден (тип пользователя не важен)                                        |       ITEM_NOT_FOUND        |
| Пользователь не найден, товар можно продать                                        |           NO_USER           |
| Пользователь не найден, товар рецептурный                                          |     NO_USER_NO_RECEIPT      |
| Пользователь не найден, товар специальный                                          |    NO_USER_SPECIAL_ITEM     |   
| Пользователь найден, товар рецептурный, у пользователя нет рецепта                 |         NO_RECEIPT          |
| Пользователь найден, товар спец. назначения                                        |       ITEM_IS_SPECIAL       |
| Пользователь врач, товар специальный, но не совпал по сфере работы врача           | ITEM_SPECIAL_WRONG_SPECIFIC |

Написание тестов - мы не требуем писать тесты в этом задании. Как убедиться в корректности работы вашего приложения вы решаете сами.




